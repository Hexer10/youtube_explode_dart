import 'dart:convert';

import 'package:collection/collection.dart';

import '../../exceptions/exceptions.dart';
import '../../extensions/helpers_extension.dart';
import '../../reverse_engineering/clients/closed_caption_client.dart' as re
    show ClosedCaptionClient;
import '../../reverse_engineering/youtube_http_client.dart';
import '../videos.dart';
import 'language.dart';

/// Queries related to closed captions of YouTube videos.
class ClosedCaptionClient {
  final YoutubeHttpClient _httpClient;

  /// Initializes an instance of [ClosedCaptionClient]
  ClosedCaptionClient(this._httpClient);

  /// Gets the manifest that contains information
  /// about available closed caption tracks in the specified video.
  ///
  /// Uses the Android API client to fetch caption tracks, as the web client
  /// requires a PO Token for videos with the exp=xpe experiment flag.
  Future<ClosedCaptionManifest> getManifest(
    dynamic videoId, {
    @Deprecated(
      'Not used anymore, use track.isAutoGenerated to see if a track is autogenerated or not.',
    ) // ignore: lines_longer_than_80_chars
    bool autoGenerated = false,
    List<ClosedCaptionFormat> formats = const [
      ClosedCaptionFormat.srv1,
      ClosedCaptionFormat.srv2,
      ClosedCaptionFormat.srv3,
      ClosedCaptionFormat.ttml,
      ClosedCaptionFormat.vtt,
    ],
  }) async {
    videoId = VideoId.fromString(videoId);
    final tracks = <ClosedCaptionTrackInfo>{};

    // Use Android API client to get caption tracks without PO Token requirement
    final captionTracks =
        await _getCaptionTracksFromApi((videoId as VideoId).value);

    for (final track in captionTracks) {
      final url = track['baseUrl'] as String?;
      final langCode = track['languageCode'] as String?;
      final nameObj = track['name'] as Map<String, dynamic>?;
      // Android API uses 'runs' format instead of 'simpleText' used by web API
      final langName =
          (nameObj?['runs'] as List?)?.firstOrNull?['text'] as String?;
      final vssId = track['vssId'] as String?;

      if (url == null || langCode == null) continue;

      final isAutoGen = vssId?.toLowerCase().startsWith('a.') ?? false;

      for (final ext in formats) {
        tracks.add(
          ClosedCaptionTrackInfo(
            Uri.parse(url).replaceQueryParameters({'fmt': ext.formatCode}),
            Language(langCode, langName ?? ''),
            isAutoGenerated: isAutoGen,
            format: ext,
          ),
        );
      }
    }
    return ClosedCaptionManifest(tracks);
  }

  /// Fetches caption tracks from the Android API.
  Future<List<Map<String, dynamic>>> _getCaptionTracksFromApi(
    String videoId,
  ) async {
    final client = YoutubeApiClient.android;
    final payload = {
      ...client.payload,
      'videoId': videoId,
    };

    final response = await _httpClient.post(
      Uri.parse(client.apiUrl),
      headers: {
        ...client.headers,
      },
      body: json.encode(payload),
    );

    if (response.statusCode != 200) {
      throw TransientFailureException(
        'Failed to get caption tracks for video $videoId: '
        'HTTP ${response.statusCode}',
      );
    }

    final data = json.decode(response.body) as Map<String, dynamic>;
    final captions = data['captions'] as Map<String, dynamic>?;
    if (captions == null) return [];

    final renderer =
        captions['playerCaptionsTracklistRenderer'] as Map<String, dynamic>?;
    if (renderer == null) return [];

    final captionTracks = renderer['captionTracks'] as List<dynamic>?;
    return captionTracks?.cast<Map<String, dynamic>>() ?? [];
  }

  /// Gets the actual closed caption track which is
  /// identified by the specified metadata.
  Future<ClosedCaptionTrack> get(ClosedCaptionTrackInfo trackInfo) async {
    final response =
        await re.ClosedCaptionClient.get(_httpClient, trackInfo.url);

    final captions = [
      for (final e in response.closedCaptions)
        if (!e.text.isNullOrWhiteSpace)
          ClosedCaption(
            e.text,
            e.offset,
            e.duration,
            e.parts.map((f) => ClosedCaptionPart(f.text, f.offset)),
          ),
    ];

    return ClosedCaptionTrack(captions);
  }

  /// Returns the subtitles as a string. In XML format.
  Future<String> getSubTitles(ClosedCaptionTrackInfo trackInfo) async {
    final r = await _httpClient.get(trackInfo.url);
    return utf8.decode(r.bodyBytes, allowMalformed: true);
  }
}
